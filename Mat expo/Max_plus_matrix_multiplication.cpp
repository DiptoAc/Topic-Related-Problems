//https://codeforces.com/blog/entry/4322
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
using namespace __gnu_cxx;
template <typename T>
using oset = tree<T, null_type, less_equal<T>,rb_tree_tag, tree_order_statistics_node_update>;
mt19937 rng(chrono::system_clock::now().time_since_epoch().count());
#define ll long long
#define fast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define pb push_back
#define ok cout<<"ok"<<endl<<flush;
#define endl '\n'
#define INF 1e11
const ll M = 998244353;
const ll N = 1e6+1;
const ll LOG = 11;
void debug(vector<ll> v){for(auto it:v){cout<<it<<" ";}cout<<endl;}
ll n,m;
vector<vector<vector<ll>>>vec(10,vector<vector<ll>>(301,vector<ll>(301,-INF)));
vector<vector<ll>>v(301,vector<ll>(301));
vector<vector<ll>>u(301,vector<ll>(301));
vector<vector<ll>>g(301,vector<ll>(301));

//This function is generated by sonnet. It print matrix.
void printMatrix(vector<vector<ll>>& vex) {
    if (vec.empty() || vec[0].empty()) {
        cout << "[]" << endl;
        return;
    }
    int maxWidth = 0;
    for (int i=0;i<n;i++){
        for (int j=0;j<n;j++) {
            int width = to_string(vex[i][j]).length();
            maxWidth = max(maxWidth, width);
        }
    }
    for (int i = 0; i < n; i++) {
        cout << "[";
        for (int j = 0; j < n; j++) {
            cout << setw(maxWidth) << vex[i][j];
            if (j < n-1) cout << " ";
        }
        cout << "]" << endl;
    }
}

/*
For min-plus matrix multiplication every other node rather than the main diagonal is INF

In this case(max plus matrix multiplication) all edges costs -INF except main diagonal.

Main diagonal = 0 means theres no self loop.

If the problem statement says that there's self. Main diagonal might not be zoro for that problem.
*/
void make_unit(vector<vector<ll>>&v)
{
    ll i,j;
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            v[i][j]=(i==j?0:-INF);
        }
    }
}

//This is the modified version of matrix multiplication.
//It is called min-plus matrix multiplication. 
//Min-plus matrix multiplication is used to find the shortest path from one node to another after certain number of moves(upto 1e18 moves);
//This funtion does the opposite. This function is actually max-plus multiplication.
void multiply(vector<vector<ll>>&a, vector<vector<ll>>&b, vector<vector<ll>>&c)
{
    ll i,j,k;
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            for(k=0;k<n;k++)
            {
                a[i][j]=max(a[i][j],b[i][k]+c[k][j]);
            }
        }
    }
}

//Prd function may change according to problem statement.
bool prd(vector<vector<ll>>&v)
{
    ll i,j,k;
    for(i=0;i<n;i++)
    {
        if(v[i][i]>0){return false;}
    }return true;
}

int32_t main()
{
    fast
    ll i,j=1,k,p,q,tc=1,cs=0;
    //cin>>tc;
    while(tc--)
    {
        cin>>n>>m;
        for(i=0;i<n;i++)
        {
            vec[0][i][i]=0;
        }
        while(m--)
        {
            ll x,y,a,b;
            cin>>x>>y>>a>>b;
            x--;y--;
            vec[0][x][y]=a;
            vec[0][y][x]=b;
        }
        for(ll l=1;l<10;l++)
        {
            multiply(vec[l],vec[l-1],vec[l-1]);
        }
        ll ans=0;
        make_unit(g);

        //This method of binary search reduced the time complexity log(n) times(10 times for this problem)
        for(i=9;i>=0;i--)
        {
            ll temp=ans+(1<<i);
            make_unit(u);
            multiply(u,g,vec[i]); //Mat expo performs at least log(n) matrix multiplication. But I am only using 1 marix multiplication each time.
            if(prd(u)){g=u;ans=temp;}
        }
        if(ans>2*n){ans=-1;}
        cout<<ans+1<<endl;
    }
}
/*
Problem name: Smile House.
https://codeforces.com/contest/147/problem/B
*/
